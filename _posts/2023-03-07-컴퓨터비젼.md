---
layout: post
title: 컴퓨터비젼 - Binary Image Analysis
subtitle: 김창수 교수님의 Binary Image Analysis 내용 정리
gh-repo: 
gh-badge: 
tags: 
comments: true
---

## Binary Image  

 Binary Image **B** 는 두 가지의 색깔로 이루어진 이미지를 의미하는데 보통 Black(1) 과 White(0) 를 사용한다. **B** 의 row 와 column 을 고려하여 **B**[r,c]의 binary value 를 따져 White 는 0의 값으로 Background(배경)를 뜻하며 Black 이 1로 Foreground 를 구성하게 된다. 

![image](https://user-images.githubusercontent.com/32359257/223438270-424d89b6-06b5-4cee-96ed-f71e51fc3661.png)

 위의 사진에서는 **B**[0,0] = 0 의 값을 가지며 흰색 pixel 을 가지게 되지만 **B**[1,1] = 1 의 값을 가져 검은색 pixel 을 가지게 된다.  

## Masking
 Masking은 사실 convolution과 동일한 연산을 image에서 하는 것이다. Mask를 적용하고자 하는 input image의 각 픽셀에 대해 mask를 적용해 이를 output image의 동일한 위치의 픽셀에 결과값을 저장하면 된다. 이 때, Mask는 보통 Normalize 되어 Input 과 Output 간의 평균값 차이 발생을 방지한다.  
![image](https://user-images.githubusercontent.com/32359257/223449857-837803af-2d8f-4a8f-aaed-665277f9ce22.png)  
위의 예시에서 노란색 위치의 Input 에 대해 Normalize 된 Mask 를 적용하면 Output의 동일한 위치에 있는 pixel에 800/16 = 50 의 결과값이 저장되게 된다. 이렇게 모든 Input에 대해 적용하는 것이 Masking 이다. 그러나 Input의 제일 첫 번째 픽셀의 경우에는 Mask하기 위해 특정 pixel들의 값을 가져오기 어려운 경우가 있는데 이럴 경우 zero-padding을 활용하면 된다.
 
## Counting Objects in an Image  
 사람은 사진을 봤을 때 사물로 인식하는 것이 크게 어렵지 않다. 그러나 컴퓨터의 입장에서는 굉장히 어려운 작업이다. 따라서 다음과 같은 방법들을 사용해 컴퓨터에게 사물을 인식할 수 있도록 한다.  
#### Corner Patterns
 2X2 Masking을 특정 패턴들을 활용해 구별하는 방법이다. 
![image](https://user-images.githubusercontent.com/32359257/223445427-646f7c37-a62b-45e4-92c5-40df86ef7576.png)  
![image](https://user-images.githubusercontent.com/32359257/223445798-94e3a5df-dd9f-47f2-b24f-84c19f45d23b.png)  
 위 두 개의 패턴들을 대입하여 # of objects = (External patterns - Internal patterns)/4 로 구하면 된다. 이의 증명은 귀납법을 활용해 소개해주셨었다. (필력이 부족하여 자세한 설명이 되지 않는 점 미리 양해를 구한다)
 검은 픽셀의 개수를 n이라고 하였을 때 n =1 일 때는 위 공식이 정상적으로 적용됨을 알 수 있다. 만약 n=k일 때 성립함을 가정하고 n=k+1 인 경우에 대해 공식이 성립하는지 보면 증명이 될 것이다. n=k+1인 경우는 n=k인 경우에서 단 1개가 추가된 경우인데 이 때 추가된 pixel의 좌표를 (0,0)으로 잡고 생각해보자. (0,0)을 기준으로 주변 8칸에 대해서만 생각하면 되므로 즉, 3X3 에서 pattern을 살펴보자! (0,0)이 추가될 검은 pixel이고 N은 기존의 3X3 구역 내 존재하는 검은 pixel들이라고 하자.
##### N=1, 2, 3
![image](https://user-images.githubusercontent.com/32359257/223446503-aac8ac5f-d526-4c07-b884-5789263c98d3.png)  
##### N=3, 4, 5
![image](https://user-images.githubusercontent.com/32359257/223446556-836aa89b-3ffd-4f05-9c9f-f1bd9aeae2e1.png)  
##### N=5, 6, 7
![image](https://user-images.githubusercontent.com/32359257/223446611-032129d0-2435-45e9-bf7f-0201c8433fdd.png)  

(회전, 대칭 경우 모두 고려하였다)  
(0,0)이 추가되기 전과 후를 비교하여서 E와 I 값이 변하는 것을 구했을 때 모든 경우에 대해서 변화량이 동일하다는 것을 알 수 있다. 즉, # of objects의 값이 변하지 않는다는 결론을 확인할 수 있다.  
 그러나 해당 방법에는 단점들이 존재한다.
 ![image](https://user-images.githubusercontent.com/32359257/223454246-c64f2559-b81e-4c38-9165-d74421990181.png) 
위 사진의 두 경우와 같이 꼭지점(vertex)를 공유하거나 hole이 존재하는 경우에는 위 방법을 사용하기 어렵다.

## Neighborhoods
![image](https://user-images.githubusercontent.com/32359257/223455492-4a739baf-0edb-42f1-91ea-24cb10c6351d.png)

## Connectedness








